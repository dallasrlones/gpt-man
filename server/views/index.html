<!DOCTYPE html>
<html lang="en">

<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT-Man</title>
    <style>
        body {
            background-color: #586168;
            color: white;
            padding: 15px;
        }

        /* button {
            border: none;
            border-radius: 5px;
            padding: 12px;
            background: #3f3f40;
            color: white;
            font-weight: bold;
        } */

        #context {
            width: 100%;
        }

        #document {
            width: 50%;
            margin: 0 auto;
        }

        .page-info {
            background-color: white;
            color: #1d1d1d;
            margin: 0;
            padding: 15px;
        }

        .page {
            background-color: white;
            color: #1d1d1d;
            /* margin-bottom: 15px; */
            margin-bottom: 15px;
            padding: 15px
        }

        .btn-primary {
            background: #3f3f40;
            border: 1px solid white;
        }

        .btn-primary:hover {
            background: #0985d2;
        }
    </style>
</head>

<body>
    <div id="status">
        <h1>Host: <span id="host"></span>:1337</h1>
        <div id="status-wrapper">
            <span id="status-text">Idle</span> | <span id="gpt-status"></span>
        </div>
        <!-- items in queue -->
        <div id="queue-wrapper">
            <span id="queue">0</span> Items in Queue
        </div>

        <!-- questions asked, questions answered, questions procesedd -->
        <div id="questions">
            <span id="asked">0</span>/<span id="answered">0</span>/<span id="processed">0</span>
        </div>

    </div>
    <div id="menu">
        <input type="text" id="document-name" style="width: 40%; height: 40px" placeholder="Document Name">
        <span style="width: 50%;">
            <button id="create-document-small" class="btn btn-primary" onclick="createDocument('SMALL')">Create Small
                Document</button>
            <button id="create-document-medium" class="btn btn-primary" onclick="createDocument('MEDIUM')">Create Medium
                Document</button>
            <button id="create-document-large" class="btn btn-primary" onclick="createDocument('LARGE')">Create Large
                Document</button>
        </span>

    </div>
    <hr>
    <textarea id="context" placeholder="Context"></textarea>
    <hr>
    <div id="document">

    </div>
</body>

</html>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
    crossorigin="anonymous"></script>

<script>
    const selectors = {
        document: () => (document.getElementById('document')),
        documentName: () => (document.getElementById('document-name')),
        context: () => (document.getElementById('context')),
        createDocumentSmall: () => (document.getElementById('create-document-small')),
        createDocumentMedium: () => (document.getElementById('create-document-medium')),
        createDocumentLarge: () => (document.getElementById('create-document-large')),
        queue: () => (document.getElementById('queue')),
        asked: () => (document.getElementById('asked')),
        answered: () => (document.getElementById('answered')),
        processed: () => (document.getElementById('processed')),
        gptStatus: () => (document.getElementById('gpt-status')),
        host: () => (document.getElementById('host')),
    };

    const http = {
        get: (url) => {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText));
                    }
                };
                xhr.send();
            });
        },
        put: (url, data) => {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText));
                    }
                };
                xhr.send(JSON.stringify(data));
            });
        },
        post: (url, data) => {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText));
                    }
                };
                xhr.send(JSON.stringify(data));
            });
        }
    };

    const handleServerError = (error) => {
        console.log(error);
    };

    const handleResponseError = (response) => {
        if (response.success === false) {
            console.log(response.error);
        }
    };

    const sendPayload = (payload) => {
        http.post('/payload', payload).then(handleResponseError).catch(handleServerError);
    };

    const createDocument = (size) => {
        const documentName = selectors.documentName().value;
        const context = selectors.context().value;
        if (!documentName || !context) { return; }
        const payload = { action: `CREATE_DOCUMENT_${size}`, payload: { documentName, context } };
        sendPayload(payload);
    };

    // add listeners for context
    const fetchState = () => {
        http.get('/state').then((response) => {
            selectors.queue().innerHTML = response.serverState.queue.length;
            selectors.gptStatus().innerHTML = response.gptState.state.status;
        }).catch(handleServerError);
    };

    const fetchContext = () => {
        http.get('/context').then((response) => {
            selectors.context().value = response.context;
        }).catch(handleServerError);
    };

    const fetchIP = () => {
        http.get('/ip').then((response) => {
            state.ip = response.ip;
            selectors.host().innerHTML = state.ip;
        }).catch(handleServerError);
    };

    const state = {
        outline: {},
        ip: ''
    };

    const formatOutline = () => {
        const outline = state.outline;
        const outlineKeys = Object.keys(outline);
        let htmlString = '';
        outlineKeys.forEach((title) => {
            htmlString += `<div><h1 class="page-info">${title}</h1>`;
            const subtitles = outline[title];
            const subtitleKeys = Object.keys(subtitles);
            subtitleKeys.forEach((subtitle) => {
                htmlString += `<div class="page"><h2>${subtitle}</h2>`;
                const sections = subtitles[subtitle];
                if (typeof sections == 'string') {
                    htmlString += `<p>${sections}</p>`;
                    htmlString += '</div>';
                } else {
                    const sectionKeys = Object.keys(sections);
                    sectionKeys.forEach((section) => {
                        htmlString += `<div><h3>${section}</h3>`;
                        const talkingPoints = sections[section];
                        const talkingPointKeys = Object.keys(talkingPoints);
                        talkingPointKeys.forEach((talkingPoint) => {
                            htmlString += `<p>${talkingPoints[talkingPoint]}</p>`;
                        });
                        htmlString += '</div>';
                    });
                    htmlString += '</div>';
                }
            });
            htmlString += '</div>';
        });
        return htmlString;
    };

    const fetchOutlineAndFormatOnPage = () => {
        http.get('/outline').then((response) => {
            state.outline = response;
            selectors.document().innerHTML = formatOutline();
        }).catch(handleServerError);
    };

    const initialize = () => {
        fetchIP();
        // get state
        fetchState();
        // populate context
        fetchContext();

        setInterval(loop, 1000);
    };

    const loop = () => {
        // fetch state, update ui
        fetchOutlineAndFormatOnPage();

    };

    initialize();

    selectors.context().addEventListener('input', () => {
        state.context = selectors.context().value;
        http.post('http://localhost:1337/context', { context: state.context })
            .then(handleServerError).catch(console.log);
    });

</script>